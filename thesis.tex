\documentclass[11pt,twoside,a4paper]{article}
\usepackage{enumitem}
\usepackage{stix2}
\usepackage[utf8]{inputenc}
\usepackage{textcomp}
\usepackage{gensymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{url}
\usepackage{hyperref}
\usepackage{mathrsfs}
\usepackage{multicol}
\usepackage{tikz}
\usepackage{amsthm}
\usepackage{natbib}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{verbatim}
\usepackage[margin=2cm]{geometry}
\DeclareMathOperator{\poly}{\mathsf{poly}}
\DeclareMathOperator{\Enc}{\mathsf{Enc}}
\DeclareMathOperator{\Dec}{\mathsf{Dec}}
\DeclareMathOperator{\Sim}{\mathsf{Sim}}
\newcommand{\commit}{\mathsf{Com}}
\newcommand{\PrfEnc}{\mathsf{PrfEnc}}
\newcommand{\PrfKnow}{\mathsf{PrfKnow}}
\newcommand{\rerand}{\mathsf{Rerandomise}}
\newcommand{\PrfRerand}{\mathsf{PrfRerand}}
\newcommand{\dlog}{\mathsf{dlog}}
\newcommand{\MixDec}{\mathsf{MixDecrypt}}
\newcommand{\pet}{\mathsf{PlaintextEquivalent}}
\newcommand{\vid}{\textit{VoterID}}
\newcommand{\receivedvid}{\textit{RecVoterID}}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\renewcommand{\bibsection}{}
\title{Verifiable Vote-by-mail\\\large Submitted in partial fulfillment of the requirements of the degree of Master of Science (Computer Science)}
\author{Eleanor McMurtry\\\\School of Computing and Information Systems\\University of Melbourne\\\\Supervised by Vanessa Teague \& Chris Culnane}
\begin{document}
\maketitle
\pagebreak
\tableofcontents
\vfill\pagebreak
\section{Introduction}
Remote voting is on the rise worldwide, either in the form of online or postal voting. Online voting can often suffer from unreasonable trust assumptions and verifiability issues that do not arise from postal voting; however, the latter is difficult to administrate. Current postal voting systems rely on a send-and-return model that introduces long delays and opportunities for fraud. We aim to investigate how an electronically-generated ballot can allow one-way postal voting, and how a cryptographic protocol can produce integrity guarantees. We will analyse the minimal trust assumptions needed for such a system, demonstrate desirable verifiability and receipt-freeness properties of the protocol, and provide a draft implementation of the protocol.
\subsection{Contributions}
We present a novel remote voting protocol that allows postal voting to be verifiable and (passively) receipt-free. To our knowledge, we are the first to propose a remote voting system with paper assurance that allows both verifiability and receipt-freeness. The protocol is verifiable under the assumption that an adversary controls \textit{either}
\begin{itemize}
    \item the voter's device; or
    \item the postal service and/or the electoral commission
\end{itemize}
It is therefore not \textit{universally} verifiable. The protocol is \textit{passively} receipt-free, meaning that an honest but curious voter who follows the protocol cannot produce a receipt of how they voted. However, a voter who actively deviates from the protocol can. Defence against this is a topic for future work.
\subsection{Related work}
\subsection{Organisation}
Section~\ref{sec-background} discusses the theoretical background relied upon for the verifiable vote-by-mail system. Sections~\ref{sec-protocol}-\ref{sec-properties} describe the protocol in depth, as well as the assumptions it relies on and the properties it has under those assumptions. Sections~\ref{app-elgamal}-\ref{app-proof}  are appendices that expand on the theoretical underpinnings of the cryptographic tools used, explaining the mathematical tools used and practical considerations for implementations.
\section{Background}\label{sec-background}
\subsection{Remote voting}
\subsection{Election models}
\subsection{Cryptographic primitives}
We use the following key cryptographic primitives in the protocol:
\begin{enumerate}
    \item Pedersen commitment schemes
    \item Randomised asymmetric encryption schemes (using the ElGamal cryptosystem, discussed in more detail in section~\ref{app-elgamal})
    \item Message authentication codes (MACs)
    \item Zero-knowledge proofs (discussed in more detail in section~\ref{app-proof})
    \item Cryptographic mixes (also discussed in section~\ref{app-proof})
\end{enumerate}
The notation we will use is as follows:
\begin{itemize}
	\item $\commit(a;r_a)$ meaning a perfectly-hiding Pedersen commitment to the values $a, r_a$
	\item $\{m\}_{pk}$ meaning an ElGamal encryption of message $m$ with public key $pk$, optionally producing:
	\begin{itemize}
		\item $\PrfEnc(m, \{m\}_{pk})$, a universally-verifiable proof that $\{m\}_{pk}$ is an encryption of $m$
		\item $\PrfKnow(\{m\}_{pk})$, a universally-verifiable zero-knowledge proof that the encryptor knows the encrypted message $m$
	\end{itemize}
	\item $\pet_T(a, b)$ meainng a plaintext equivalence test with universal verifiability performed by a set of trustees $T$
	\item $\rerand\{m\}_{pk}$ meainng a re-randomisation of the encryption $\{m\}_{pk}$ such that it is computationally infeasible to tell that both decrypt to the same message without knowing the secret key $sk$, optionally producing:
	\begin{itemize}
		\item $\PrfRerand(\{m\}_{pk}, \{m\}'_{pk})$, a universally-verifiable zero-knowledge proof that $\{m\}'_{pk}$ is a rerandomisation of $\{m\}_{pk}$
	\end{itemize}
	\item $\MixDec(\mathcal{S})$ meaning a universally-verifiable mix and decryption of the set $\mathcal{S}$ (with the associated zero-knowledge proofs). If elements of $\mathcal{S}$ are tuples, only some of the tuple elements may be decrypted.
\end{itemize}

The commitment scheme is used to confirm voters' identity via randomly-chosen parameters \((a, b, r_a, r_b)\). These parameters cannot be revealed before votes are received, so a commitment is posted instead of the values themselves. The message authentication code \(MAC = a\cdot Vote+b\) is the key innovation of the protocol, and is used to ensure a vote cannot be secretly swapped for another. Because the voter's parameters \((a, b)\) define a line, it is exponentially unlikely that an adversary could modify the MAC and vote consistently without knowing \(a\) and \(b\).
\subsection{E-voting protocols}
\section{The protocol}\label{sec-protocol}
\subsection{Setup}
Before any voter can cast a vote, some public parameters must be established. Choose \(n\) electoral trustees, who should be mutually distrusting; good candidates include state electoral commissions and representatives from major parties. Generate an exponential ElGamal key-pair \((pk, sk)\) shared among the \(n\) trustees such that any \(k\) of them can decrypt a given ciphertext. Also generate public parameters \((G, H, P)\) of a Pedersen commitment scheme.

Each voter should be assigned a unique ID number. This assignment does not have to remain secret, and the electoral commission should be able to identify voters by their ID.

A write-only web bulletin board should be online and accessible to all parties.
\subsection{Casting a ballot}
Before creating a ballot, the voter's device must choose secret parameters that will be used to generate a MAC. It should choose \(a,b,r_a,r_b\) uniformly at random from the ElGamal group, and post
\[\big(VoterID,\ \commit(a;r_a),\ \commit(b;r_b)\big)\]
to the WBB, committing to its parameters.

To create the ballot, the voter enters their vote on the device, which is encoded as a number \(Vote\). The device calculates \(MAC=a\cdot Vote+b\), and sends (e.g. via the Internet)\footnote{We assume for ease of exposition that this Internet connection is untappable. In practice, this is not really the case, and defences against this are an open question.}
\[\left(VoterID,\ \{Vote\}_{pk},\ \{MAC\}_{pk}\right), \PrfKnow(\{Vote\}_{pk}, \PrfKnow(\{MAC\}_{pk}))\]
to the electoral commission. The electoral commission checks the proofs (to ensure the device did not simply send random values), re-randomises the encryptions, and posts the result to the WBB, effectively committing to a vote and its corrseponding MAC.\footnote{This defeats a randomisation attack, where a cheating electoral commission invalidates votes by randomising the MAC or vote.} Once the device verifies its ID has an encrypted vote and MAC on the WBB, it produces a ballot with two separate pieces of paper
\[\textit{Paper1} = \left(Vote,\ \{VoterID\}_{pk},\ \{a,b,r_a,r_b\}_{pk}, \PrfKnow(\{a,b,r_a,r_b\}_{pk})\right)\]
\[\textit{Paper2} = \left(VoterID, \{VoterID\}_{pk}, \PrfEnc(VoterID, \{VoterID\}_{pk})\right)\]
The idea of \textit{Paper2} is to prove to the electoral commission that the voter ID on the ballot is that of the correct voter without allowing a worker who performs this check to see the vote (thereby breaking privacy).

After doing this, the voter can simply mail their paper ballot to the electoral commission, providing whatever identification details are usual in their jurisdiction (e.g. writing their name and address on the envelope).
\subsection{Receiving a ballot}
Once the ballot casting period has ended, the electoral commission can begin receiving ballots. First, the electoral commission checks
\[\textit{Paper2}=\left(ReceivedVoterID, \{ReceivedVoterID\}_{pk},\PrfEnc(ReceivedVoterID, \{ReceivedVoterID\}_{pk}\right)\]
They should confirm that \(ReceivedVoterID\) matches the identification on the envelope. If it does, they should attach the encryption \(\{ReceivedVoterID\}_{pk}\) to \textit{Paper1} (without opening it)\footnote{This could be done by e.g. tearing \textit{Paper2} and stapling it to \textit{Paper1}, or even by providing \(\{ReceivedVoterID\}_{pk}\) on a third piece of paper.}, and destroy the rest of \textit{Paper2}. \textit{Paper1} from all ballots should now be shuffled physically, to preserve privacy.
\[\textit{Paper1}=\left(ReceivedVote,\ \{ReceivedVoterID\}_{pk},\ \{a,b,r_a,r_b\}_{pk}, \PrfKnow(\{a,b,r_a,r_b\}_{pk}\right)\]
The electoral commission should check the proofs, and if they are valid, post the re-randomised received ballot to the WBB. This should be performed under scrutiny from e.g. party representatives to ensure they are faithfully posted; this is the only step that needs active scrutineering.

The electoral trustees next perform a cryptographic mix to produce a list of ballots of the form
\[\left(\{ReceivedVote\}_{pk},\ ReceivedVoterID,\ (a,b,r_a,r_b)\right)\]
on the WBB. The resulting list should be joined to the commitments on the WBB by matching \(ReceivedVoterID\) to \(VoterID\), producing a list of tuples
\[\left(\{ReceivedVote\}_{pk},\ VoterID,\ (a,b,r_a,r_b), \commit(a;r_a), \commit(b;r_b)\right)\]
If there are multiple tuples for some \(VoterID\), for each tuple the pair of commitments \(\commit(a;r_a), \commit(b;r_b)\) should be checked. If the parameters \(a,b,r_a,r_b\) are correct openings for exactly one tuple, only that tuple should be accepted; in any other case, no tuples for \(VoterID\) should be accepted.

The accepted tuples should then be matched with the electoral commission's commitments to produce a list of tuples
\[\left(\{Vote\}_{pk},\{MAC\}_{pk}, \{ReceivedVote\}_{pk},\ VoterID,\ a, \{b\}_{pk}, \PrfEnc(b, \{b\}_{pk})\right)\]
\subsection{Counting ballots}
For all accepted tuples, the electoral trustees should perform a plaintext equivalence test on the WBB to show whether \(ReceivedVote=Vote\) (without decrypting either). If this succeeds, using the homomorphic property of exponential ElGamal the electoral commission\footnote{This does not require the secret key, so it can be easily verified by any party.} constructs a second MAC from the received vote:
\[\{MAC'\}_{pk}=a\cdot\{ReceivedVote\}_{pk}+\{b\}_{pk}\]
This is posted to the WBB with the voter ID and the committed vote-MAC pair:
\[\left(VoterID, \{Vote\}_{pk},\ \{MAC\}_{pk},\ \{MAC'\}_{pk}\right)\]
The electoral trustees perform another plaintext equivalence test on the WBB to show that \(MAC=MAC'\). For all tuples that pass this test, the electoral trustees should decrypt \(\{Vote\}_{pk}\) to produce a final list of valid votes.

Note that anybody can check whether a given voter ID produced a valid vote by seeing whether a tuple \(\left(VoterID, \{Vote\}_{pk},\ \{MAC\}_{pk},\ \{MAC'\}_{pk}\right)\) passed the final plaintext equivalence test, providing \textit{individual} verifiability. It is easy to modify the protocol to remove this property, instead providing \textit{group} verifiability; this may be desirable depending on the application.
\subsection{Verification protocol}
We provide a summary of the various checks that need to be performed to verify the election. Verification is broken into three separate domains. Each voter must check the paper printout herself, and whether her ID appears in the final mix. Scrutineers from third parties must observe the process of receiving paper ballots. Finally, the WBB transcript can in theory be verified by anyone; because this may not be a trivial computational task, we expect that trusted entities such as media organisations would perform verification of this transcript on the behalf of voters.

\subsubsection{By the voter}
Before sending their vote by mail, the voter should check that the printed ballot paper matches the vote they intend to cast. Once the receiving process is complete, if the voter wishes, they can check whether their voter ID passed the verifications and plaintext equivalence tests on the WBB; if it did not, their vote was not accepted.

\subsubsection{By election scrutineers}
Scrutineers that are present when the received envelopes are opened must check:
\begin{enumerate}
	\item that the received voter ID matches the entry on the electoral roll;
	\item that the proof of encryption on Paper 2 is correct;
	\item that Paper 2 was correctly attached to Paper 1; and
	\item that the vote posted to the WBB matches the vote on Paper 1.
\end{enumerate}

\subsubsection{Of the WBB}
To ensure correctness of the WBB transcript, any third party (optionally including voters) should check:
\begin{enumerate}
	\item the first mix and decryption proofs
	\item that the claimed commitment openings are correct openings
	\item that there is exactly one correct commitment opening for each accepted voter ID
	\item that ReceivedVoterID and VoterID are correctly joined to the MAC and vote committed to by the EC
	\item that ReceivedVoterID = VoterID for each row
	\item any provided proofs of plaintext equality
	\item that only votes that pass the plaintext equality tests are included in the final stage
	\item the final mix and decryption proofs
\end{enumerate}
\section{Trust assumptions}
\section{Properties of the protocol}\label{sec-properties}
\subsection{Verifiability}
\subsection{Receipt-freeness}
\section{Conclusion}
\vfill\pagebreak
\section{Appendix 1: ElGamal encryption}\label{app-elgamal}
\subsection{Overview}
The ElGamal cryptosystem is an asymmetric probabilistic encryption scheme. We give a definition of the scheme, and discuss some group theory relevant to its practical implementation.
\begin{definition}{The ElGamal encryption scheme}\\
    Let \(\mathbb{G}\) be a cyclic group and \(g\in\mathbb{G}\) be an element of prime order \(q\). Choose \(s\in\mathbb{Z}_q\) uniformly at random, and let \(h=g^s\). The public key of the scheme is \((\mathbb{G}, g, q, h)\), and the secret key is \((\mathbb{G}, g, q, s)\). We will choose messages in the group \(\mathbb{Z}^\times_q\).

    Given a uniformly random \(r\in\mathbb{Z}\), define the encryption \(\Enc_r:\mathbb{G}\rightarrow\mathbb{G}\times\mathbb{G}\) of a message \(m\) to be
    
    \[\Enc_r(m) = (g^r, m\cdot h^r)\]

    Define the decryption \(\Dec:\mathbb{G}\times\mathbb{G}\rightarrow \mathbb{G}\) of a ciphertext \((c_1, c_2)\) to be
    
    \[\Dec(c_1,c_2)=c_2\cdot c_1^{-s}\]

    In particular, if \((c_1,c_2)\) is an encryption of \(m\) then \(c_2\cdot c_1^{-s}=m\cdot g^{rs}\cdot g^{-rs}=m\).
\end{definition}
It is not immediately clear that such a generator can be efficiently computed, or that it can be done in a cryptographically secure manner. We will show how this can be achieved.
\subsection{Choosing an appropriate group}
We will need a prime number of a particular form to produce our group.
\begin{definition}{Safe prime}\\
    A prime \(p\) is \textit{safe} if \(p=2q+1\) for some other (large) prime \(q\).
\end{definition}
Let \(\mathbb{G}=\mathbb{Z}^\times_p\) be the multiplicative group of integers modulo a safe prime \(p=2q+1\). We first demonstrate that this is a cyclic group of order \(p-1=2q\). The proof is due to \cite{cyclicity}.
\begin{lemma}\label{lem-order-divides}
    Let \(G\) be a finite abelian group, and \(n\) be the maximal order among elements of \(G\). Then for all \(g\in G\), the order of \(g\) divides \(n\).
\end{lemma}
\begin{proof}
    Let \(g\in G\) have the maximal order \(n\). Let \(h\in G\) with order \(m\). Suppose by way of contradiction that \(m\) does not divide \(n\). Then there is some prime \(p\) with a power in \(m\) greater than its power in \(n\). Let \(p^e\) be the greatest power of \(p\) in \(m\) and \(p^f\) be the greatest power of \(p\) in \(n\). Then \(g^{p^f}h^{m/p^e}\) has order
    \[\frac{n}{p^f}p^e=np^{e-f}>n\]
    contradicting the maximality of \(n\).
\end{proof}
\begin{lemma}
    \(\mathbb{Z}^\times_p\) is cyclic with order \(p-1\).
\end{lemma}
\begin{proof}
    Let \(n\leq p-1\) be the maximal order among elements of \(\mathbb{Z}^\times_p\). Every element has order \(o\vert n\) by Lemma \ref{lem-order-divides}, so for all \(a\in\mathbb{Z}^\times_p\) we have \(a^n=1\). This equation has at most \(n\) solutions, and we have produced \(p-1\) solutions already; therefore \(p-1\leq n\).
    Combining the inequalities gives \(n=p-1\), so we have an element of order \(p-1=|\mathbb{Z}^\times_p|\) as required.
\end{proof}
Unfortunately \(\mathbb{Z}^\times_p\) does not satisfy the decisional Diffie-Hellman (DDH) assumption, so we will not have the desired security properties:
\begin{lemma}\label{lem-parity}
    Let \(g\) be a generator of \(\mathbb{Z}^\times_p\) for a prime \(p\). For all \(x\in\mathbb{Z}^\times_p\), let \(a=g^x\). Then \(a^{\frac{p-1}{2}} = 1\) if and only if \(x\) is even, and \(a^{\frac{p-1}{2}} = -1\) if and only if \(x\) is odd.
\end{lemma}
\begin{proof}
    Suppose \(x\) is even; let \(x=2y\). Then

    \[a^{\frac{p-1}{2}}=(g^x)^{\frac{p-1}{2}}=g^{2y\frac{p-1}{2}}=(g^{p-1})^y=1\]

    Suppose \(x\) is not even; let \(x=2y+1\). Then

    \[a^{\frac{p-1}{2}}=(g^x)^{\frac{p-1}{2}}=g^{(2y+1)\frac{p-1}{2}}=(g^{p-1})^yg^{\frac{p-1}{2}}=g^{\frac{p-1}{2}}\neq 1\]

    In particular \(g\) is a generator so \(g^\frac{p-1}{2}\neq 0\). By Fermat's little theorem we have \(a^{p-1}=1\) or equivalently in the prime ring \(\mathbb{Z}_p\)

    \[\left(a^\frac{p-1}{2}-1\right)\left(a^\frac{p-1}{2}+1\right)\equiv 0\bmod p\]
    
    In the case under discussion, we are left with \(a^\frac{p-1}{2}=-1\).
\end{proof}
\begin{theorem}
    \(\mathbb{Z}^\times_p\) does not satisfy DDH.
\end{theorem}
\begin{proof}
    Let \(g\in\mathbb{Z}^\times_p\) be a generator and \(a,b\in\mathbb{Z}^\times_p\) be arbitrary. By Lemma \ref{lem-parity}, \((g^a)^{\frac{p-1}{2}}=1\) if and only if \(a\) is even, and similarly \((g^b)^{\frac{p-1}{2}}=1\) if and only if \(b\) is even. So, given \(g^a\) and \(g^b\), we can determine the value of \(\left(g^{ab}\right)^\frac{p-1}{2}\): it is 1 if and only if \(a\) and \(b\) are not both odd, and \(-1\) otherwise. Thus we can distinguish \(g^{ab}\) from \(g^c\) for a random \(c\in\mathbb{Z}^\times_p\).
\end{proof}
Happily, there is a \textit{subgroup} of \(\mathbb{Z}^\times_p\) that is believed to satsify DDH.
\begin{definition}{Quadratic residue}\\
    \(a\) is a \textit{quadratic residue} mod \(p\) if there exists \(x\in\mathbb{Z}\) such that

    \[x^2=a\bmod p\]

\end{definition}
\(\mathbb{Z}^\times_p\) has a subgroup of order \(q\) (since \(p-1=2q\)). Euler's criterion tells us that there are \(\frac{p-1}{2}=q\) quadratic residues modulo \(p\), so we might hope that this subgroup is precisely the quadratic residues modulo \(p\). For the below discussion, we assume that \(p>3\).
\begin{lemma}
    The quadratic residues mod \(p\) form a group under multiplication.
\end{lemma}
\begin{proof}
    Let \(x^2,y^2\in\mathbb{Z}^\times_p\) be quadratic residues mod \(p\). Then \(x^2y^2=(xy)^2\) is also a quadratic residue, as is \((x^2)^{-1}=(x^{-1})^2\) (where \(x^{-1}=x^{p-2}\)). Associativity is automatic.
\end{proof}
\begin{lemma}
    The group of quadratic residues mod \(p=2q+1\) is the subgroup of \(\mathbb{Z}^\times_p\) of order \(q\).
\end{lemma}
\begin{proof}
    Clearly \(2^2\) is a quadratic residue and does not have order 2 or 1. \({2^2}^q=2^{2q}=2^{p-1}=1\) so it has order \(q\), and thus generates the subgroup of order \(q\).
\end{proof}
We therefore have a good candidate cyclic group for our ElGamal cryptosystem: choose a safe prime \(p=2q+1\), and take the subgroup of \(\mathbb{Z}^\times_p\) generated by \(4\). It remains to find a way to encode data as elements of this group; one possible choice is outlined below \cite{katz2014introduction}.

Let \(\mathbb{G}_p\) be the group of quadratic residues modulo a safe prime \(p\).
\begin{theorem}
    Let \(p\) be a safe prime congruent to 3 modulo 4 (so \(p=4i+3\) for some \(i\in\mathbb{Z}\)).

    \[\pi:\mathbb{Z}_q\rightarrow\mathbb{G}_p,\ \pi(m)=(m+1)^2\bmod p\]

    is a bijection with inverse

    \[\pi^{-1}(x)=-1+\begin{cases}
        x^\frac{p+1}{4} & x^\frac{p+1}{4}\leq q\\
        -x^\frac{p+1}{4}&\text{otherwise}
    \end{cases}\]

\end{theorem}
\begin{proof}
    Note that \(x^\frac{p-1}{2}=1\) by Lemma \ref{lem-parity}, since \(x\) is a quadratic residue. Then we have as one square root

    \[x=x^{\frac{p-1}{2}+1}=x^{2i+2}=(x^{i+1})^2=\left(x^\frac{p+1}{4}\right)^2\]

    To find the other square root:

    \[\left(p-x^\frac{p+1}{4}\right)^2=p^2-2px^\frac{p+1}{4}+x^\frac{p+1}{2}\equiv x^\frac{p+1}{2}\bmod p=x^{q+1}=x\]

    Since \(q=\frac{p-1}{2}\) exactly one of these is less than or equal to \(q\). The domain and codomain have the same cardinality, so the map is bijective.

    %For the isomorphism, we examine \(\pi^{-1}(xy)\). The interesting case is when both \(x^\frac{p+1}{4}>q\) and \(y^\frac{p+1}{4}>q\); then

    %\[\left(p-x^\frac{p+1}{4}\right)\left(p-y^\frac{p+1}{4}\right)=p^2-py^\frac{p+1}{4}-px^\frac{p+1}{4}+(xy)^\frac{p+1}{4}\equiv p-(xy)^\frac{p+1}{4}\bmod p=\pi^{-1}(xy\right)\]

\end{proof}
\subsection{Security properties of ElGamal}
\begin{definition}{Negligible function}\\
    A function \(f:\mathbb{N}\rightarrow\mathbb{R}\) is \textit{negligible} if for all polynomials \(\poly(x)\), there exists \(N>0\) such that for all \(x>N\)

    \[|f(x)|<\frac{1}{\poly(x)}\]

\end{definition}
\subsection{The homomorphic property of ElGamal}
Interestingly, the encryption and decryption functions in ElGamal are group homomorphisms. This allows us to verifiably compute certain functions of ciphertexts without ever revealing the decryption.
\begin{lemma}\label{lem-mul-homom}
    \(\Enc_r\) and \(\Dec\) are multiplicative group homomorphisms.
\end{lemma}
\begin{proof}
    We will treat \(\Enc_r\) as a function \(\mathbb{Z}_q\times\mathbb{G}_q\rightarrow\mathbb{G}_q\times\mathbb{G}_q\) to account for the parameter \(r\).\footnote{We will use addition as the group operation on \(\mathbb{Z_q}\).}

    Let \(x,y\in\mathbb{G}_p\) and \(r_1,r_2\in\mathbb{Z}\). For encryption:
    
    \[\Enc_{r_1}(x)\cdot\Enc_{r_2}(y)=(g^{r_1},xh^{r_1})\cdot(g^{r_2},yh^{r_2})=(g^{r_1+r_2},xyh^{r_1+r_2})=\Enc_{r_1+r_2}(xy)\]

    For decryption:

    \[\Dec(g^{r_1},xh^{r_1})\cdot\Dec(g^{r_2},yh^{r_2})=xg^{r_1s}g^{-r_1s}yg^{r_2s}g^{-r_2s}=xy=\Dec(g^{r_1+r_2},xyh^{r_1+r_2})\]
\end{proof}

We now construct an \textit{additive} homomorphism:
\begin{lemma}
    \(e:\mathbb{Z}_q\times\mathbb{Z}_q\rightarrow\mathbb{G}_q\times\mathbb{G}_q,\ e(r, x)=\Enc_r(g^x)\) is an additive group homomorphism.
\end{lemma}
\begin{proof}
    We perform a straightforward calculation:
    \[e(r_1, x)\cdot e(r_2,y)=(g^{r_1},g^xh^{r_1})\cdot(g^{r_2},g^yh^{r_2})=(g^{r_1+r_2},g^{x+y}h^{r_1+r_2})=e(r_1+r_2, x+y)\]
\end{proof}
Unfortunately, decryption now reduces to the discrete logarithm problem -- exactly what we assume is hard to give ElGamal its security properties. In practice, this limits the additive homomorphic property to messages drawn from a small set\footnote{A not-very-clever implementation we tested on an Intel Core i7 - 8550U CPU was able to compute the discrete logarithm of 10-bit messages with a 3072-bit key in less than 20 milliseconds.} (so that the discrete logarithm can be computed quickly enough).
\subsection{Sharing a key between trustees}

\vfill\pagebreak
\section{Appendix 2: Zero-knowledge proofs and cryptographic mixes}\label{app-proof}
\subsection{Overview}
A \textit{zero-knowledge proof} typically considers a situation where one party, the \textit{prover}, knows a secret (typically satisfying some conditions) and wishes to demonstrate this knowledge to the other party, the \textit{verifier}. Zero-knowledge proofs rely on three key properties:
\begin{enumerate}
    \item \textit{completeness}: if the prover honestly knows the secret, they must be able to construct a valid proof.
    \item \textit{soundness}: a dishonest prover (who does not know the secret) must not be able to construct a valid proof, except with negligible probability
    \item \textit{zero-knowledge}: an eavesdropper must learn nothing apart from that the prover knows a secret satisfying the required conditions
\end{enumerate}
These properties are formalised below.
\subsubsection{Zero-knowledge}
The idea is to show there is a simulator that could produce an accepting conversation, for then an adversary learns nothing from eavesdropping on the conversation -- since they could have just simulated it instead.~\cite{boneh2015graduate}
\begin{definition}{Honest verifier zero knowledge}\\
    A protocol is \textit{honest verifier zero knowledge} if there exists a probabilistic polynomial time \textit{simulator} \(\Sim\) such that its output distribution is identical to that of a conversation between the prover \(P\) and (honest) verifier \(V\).
\end{definition}
It is counter-intuitive that we may assume the verifier is honest; what is the use of zero-knowledge if a cheating verifier can cause a prover to leak information? However, it is possible transform the \textit{interactive} protocols we will discuss into \textit{noninteractive} protocols -- that is, protocols where the verifier and prover are the same party -- using the \textit{Fiat-Shamir} heuristic, discussed later in this appendix. Because of this, honest verifier zero knowledge is strong enough for most applications.
\subsection{Proof of knowledge for discrete logarithms}
Consider two parties: Percy, the prover, and Valerie, the verifier. Percy publishes an ElGamal public key \((g,p,q,h)\). Percy claims that a ciphertext \((c_1, c_2)\) decrypts to a message \(m\). Valerie would like Percy to prove this claim, but Percy cannot reveal the secret key \((g,p,q,s)\) to allow Valerie to check this herself.

We first discuss how Percy can prove that he knows a secret \(r\) such that \(g^r=h\), and expand on various applications of this protocol later, following the treatment of \cite{damgaard2002sigma}.

Suppose Percy has published an element \(g\in\mathbb{Z}^\times_p\) of order \(q\) and \(h\in\mathbb{Z}^\times_q\). Valerie would like to check that Percy knows \(r\) such that \(h=g^r\). Consider the below protocol, due to Schnorr:
\begin{enumerate}
    \item Percy chooses \(w\in\mathbb{Z}^\times_q\) uniformly at random, and sends \(a=g^w\bmod p\) to Valerie.
    \item Valerie chooses a challenge \(e\in\mathbb{Z}_{2^t}\) uniformly at random, and sends it to Percy (where \(2^t<q\)).
    \item Percy sends \(z=w+er\bmod q\) to Valerie. She checks that \(g^z=ah^e\bmod p\).
\end{enumerate}

Of course, Percy could have simply guessed \(z\). But what if Percy answered two distinct challenges \(e,e'\) correctly? Then he produces \(z,z'\) such that \(g^z=ah^e\bmod p\) and \(g^{z'}=ah^{e'}\bmod p\), giving

\[g^{z-z'}=h^{e-e'}\bmod p\]

or

\[h=g^{(z-z')(e-e')^{-1}}\bmod p\]

revealing the value of \(r\). The final step is subtle: if Percy was able to answer two challenges, this would reveal \(r\), so the information Percy has must somehow contain information about \(r\). But if Percy answers two challenges, this would reveal the value of \(r\). So Percy only answers one challenge, and we have a proof that Percy knows \(r\) with probability \(1-2^{-t}\).

\subsubsection{Completeness}
\subsubsection{Soundness}
\subsubsection{Zero-knowledge}
\subsection{Proof of plaintext knowledge}
A direct application of Schnorr's protocol is proving plaintext knowledge for an ElGamal ciphertext. Percy generates an ElGamal ciphertext \((C_1, C_2)\) and uses it to prove that he knows \(r\) such that \(C_1=g^r\). While this is not a direct proof that he knows \(m\), someone who knows \(r\) can calculate \(h^r\), and therefore calculate \(m\).

\subsection{Proof of equality of discrete logarithms}


\subsection{Lifting to proof of decryption}
What does it mean to \textit{prove} that \(\Dec(g^r,mh^r)=m\)? We would like to show that \(m\cdot h^r\cdot g^{-rs}=m\) for all \(r\) and some \(s\), both of which are unknown to the verifier. We should have both \(h=g^s\) and \(h^r=(g^r)^s\); in other words, we would like to show that
\[\dlog_g{h}=\dlog_{g^r}{h^r}\]
Consider a similar protocol to the previous, modified to produce a proof of equality for discrete logarithms:
\begin{enumerate}
    \item Percy chooses \(w\in\mathbb{Z}^\times_q\) uniformly at random, and sends \(a=g^w\bmod p,b=g^{rw}\bmod p\) to Valerie.
    \item Valerie chooses a challenge \(e\in\mathbb{Z}_{2^t}\) uniformly at random, and sends it to Percy (where \(2^t<q\)).
    \item Percy sends \(z=w+es\bmod q\) to Valerie. She checks that \(g^z=ah^e\bmod p\) and \((g^r)^z=b(h^r)^e\bmod p\).
\end{enumerate}
\subsubsection{The Fiat-Shamir heuristic}
\subsection{A simple cryptographic mix}
\vfill\pagebreak
\section{References}
\bibliographystyle{unsrt}
\bibliography{papers}
\end{document}
