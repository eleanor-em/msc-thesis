\documentclass[12pt,a4paper]{article}
\usepackage[margin=1in]{geometry}
\renewcommand{\baselinestretch}{1.5} 
\usepackage{times}
\usepackage{mdframed}
\usepackage{enumitem}
\usepackage[utf8]{inputenc}
\usepackage{textcomp}
\usepackage{gensymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{url}
\usepackage{hyperref}
\usepackage{mathrsfs}
\usepackage{multicol}
\usepackage{tikz}
\usepackage{amsthm}
\usepackage{natbib}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{verbatim}
\usepackage{epigraph}
\DeclareMathOperator{\poly}{\text{poly}}
\DeclareMathOperator{\negl}{\text{negl}}
\DeclareMathOperator{\Adv}{\text{Adv}}
\DeclareMathOperator{\Gen}{\mathsf{Gen}}
\DeclareMathOperator{\Enc}{\mathsf{Enc}}
\DeclareMathOperator{\Dec}{\mathsf{Dec}}
\DeclareMathOperator{\DecDist}{\mathsf{DecDist}}
\DeclareMathOperator{\Sim}{\mathsf{Sim}}
\newcommand{\commit}{\mathsf{Com}}
\newcommand{\PrfEnc}{\mathsf{PrfEnc}}
\newcommand{\PrfKnow}{\mathsf{PrfKnow}}
\newcommand{\rerand}{\mathsf{Rerandomise}}
\newcommand{\PrfRerand}{\mathsf{PrfRerand}}
\newcommand{\dlog}{\mathsf{dlog}}
\newcommand{\pet}{\mathsf{PlaintextEquivalent}}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\theoremstyle{definition}
\newmdtheoremenv{definition}{Definition}
\newcommand{\Mix}{\mathsf{Mix}}
\newcommand{\Vote}{\mathit{Vote}}
\newcommand{\VoterID}{\mathit{VoterID}}
\newcommand{\receivedvid}{\mathit{RecVoterID}}
\newcommand{\Paper}{\mathit{Paper}}
\newcommand{\Mac}{\mathit{MAC}}
\renewcommand{\bibsection}{}

\title{Verifiable Vote-by-mail\\\large Submitted in partial fulfilment of the requirements of the degree of\\Master of Science (Computer Science)}
\author{Eleanor McMurtry (760505)\\\\\\75-point Research Project (COMP90069)\\School of Computing and Information Systems\\University of Melbourne\\\\\\Supervised by Vanessa Teague}

\begin{document}
\maketitle
\pagebreak
\tableofcontents
\newpage
\epigraph{Best practices for internet voting are like best practices for drunk driving.}{Ron Rivest}
\section{Introduction}
Remote voting is on the rise worldwide, either in the form of online or postal voting. Online voting can often suffer from unreasonable trust assumptions and verifiability issues that do not arise from postal voting. However, the latter is difficult to administrate; current postal voting systems rely on a send-and-return model that introduces long delays and opportunities for fraud. We aim to investigate how an electronically-generated ballot can allow one-way postal voting, and how a cryptographic protocol can produce integrity and privacy guarantees. We will analyse the trust assumptions needed for such a system, demonstrate desirable privacy and verifiability properties of the protocol, and provide a draft implementation.

\subsection{Contributions}
We present a novel remote voting protocol that allows postal voting to be verifiable and (passively) receipt-free. To our knowledge, we are the first to propose a remote voting system with paper assurance that allows both verifiability and receipt-freeness. The protocol is verifiable under the assumption that an adversary controls \textit{either}
\begin{itemize}
    \item the voter's device; or
    \item the postal service and/or the electoral commission
\end{itemize}
It is therefore not \textit{universally} verifiable. The protocol is \textit{passively} receipt-free, meaning that an honest but curious voter who follows the protocol cannot produce evidence as to how they voted. However, a voter who actively deviates from the protocol can create such a receipt. Defence against this is a topic for future work.

The key innovation of the protocol involves pairing votes with a \textit{message authentication code} (MAC) constructed as a function of the vote and secret parameters chosen when the vote is generated. The secret parameters define a line, meaning even if the vote and MAC are known, there are a large number of possible values for the secrets. This makes it infeasible for an adversary who does not know the secrets to generate a valid vote-MAC pair.

\subsection{Related work}
Modern democracies accept that a percentage of eligible voters will not be able to cast a vote in-person on the election day; \textit{remote voting} systems are used to allow these voters to cast a vote nonetheless. The traditional way to do this is \textit{postal voting}: a voter is sent a ballot in the mail ahead of election day, fills the ballot in with their vote, and returns the ballot by mail to the \textit{electoral commission} responsible for counting votes. However, in recent years \textit{online voting} systems have emerged, promising a more convenient and lower-cost method of remote voting~\cite{nswivote,scytlsvote}. Concurrently, there has been a trend towards remote voting globally, demonstrating a growing need for reliable and scalable voting systems~\cite{VEC_PostalVoting_Position,rallings2010,gjosteen2011norwegian}.

For almost as long as there have been public-key cryptosystems, researchers have proposed methods for using them to conduct remote voting~\cite{cohen1985robust}. One obvious application of cryptography to voting is to ensure privacy: if a vote is encrypted with the electoral commission's public key, only the electoral commission can decrypt it with their private key to determine how the vote was cast. A less-obvious application is to achieve \textit{verifiability}, whereby voters are provided with a receipt that can be used to check that their vote was included in the final count~\cite{benaloh1987verifiable}. There is a fundamental tension between this property and that of \textit{receipt-freeness}, meaning that a voter should not be able to prove how they voted after the election; this is important to prevent voters from being coerced or selling their vote~\cite{benaloh1994receipt}. The question is then: how can a voter be confident their vote was counted correctly, without giving up receipt-freeness?

One of the most influential complete systems for online voting is Helios~\cite{adida2008helios}, building on earlier foundational work by Benaloh~\cite{benaloh2006simple}. It satisfies the strong condition of \textit{end-to-end verifiability}, meaning that any observer can check the integrity of the election even if the servers and authorities running the election are corrupt. Helios has two crucial limitations: it is not receipt-free (and does not claim to be), and it has a complex verification system allowing a voter to check whether their vote was encrypted correctly. Specifically, a voter may choose to ``audit'' their encrypted vote, which generates a proof that it is an encryption of what the voter expects; if the voter does so, she must then generate another vote that can be ``sealed'' and sent for tallying. This is a complex procedure that is not easily communicated to the general public, and the integrity of the system suffers if only a small minority of voters carry out the auditing process.

Another online voting system proposed at around the same time is commonly known as JCJ~\cite{juels2010coercion}. It specifically aimed to address the receipt-freeness question, providing \textit{coercion-resistance} meaning a voter cannot prove whether or how they voted. A commonality between Helios and JCJ is the concept of a \textit{web bulletin board}: a publicly-accessible list of entries containing various kinds of data related to the election. This concept continues to be popular well into the present~\cite{kiayias2018security}. Another shared primitive is that of a \textit{shuffle proof}, where an untrusted server shuffles a list of encrypted data such that nobody except the server knows the relationship between the input and output, but everybody can be confident that no entries were added or removed; this construction has also remained popular in recent research~\cite{cortier2017machine}.

\subsection{Organisation}
Section~\ref{sec-background} discusses the theoretical background relied upon for the verifiable vote-by-mail system. Section~\ref{sec-crypto} describes in detail the cryptographic constructions we will use for the protocol, which we will rely on to prove properties of the protocol. Sections~\ref{sec-protocol}-\ref{sec-properties} describe the protocol in depth, as well as the assumptions it relies on and the properties it has under those assumptions. Sections~\ref{app-elgamal}-\ref{app-proof}  are appendices that expand on the theoretical underpinnings of the cryptographic tools used, explaining the mathematical tools used and practical considerations for implementations.

\section{Background}\label{sec-background}
\subsection{Election models}
\subsection{Remote voting}
\subsection{E-voting protocols}
\subsection{Cryptographic primitives}
% TODO: fill in primitives from paper

\section{Cryptographic tools}\label{sec-crypto}
This section presents an overview of the cryptographic constructions that are used in the protocol, including how they are defined, the properties they satisfy, and why they are used.
\subsection{The ElGamal cryptosystem}
The ElGamal cryptosystem is an asymmetric probabilistic encryption scheme defined as follows, based on the definition appearing in~\cite{katz2014introduction}.
\begin{definition}[The ElGamal cryptosystem]\label{def-elgamal}
    The generation algorithm $\Gen(\lambda)$ for security parameter $\lambda$ runs as follows: let $\mathbb{G}$ be a cyclic group and $g\in\mathbb{G}$ be an element of order $q$, where $q$ is a $\lambda$-bit prime. Choose $x\in\mathbb{Z}_q$ uniformly at random, and let $y=g^x$. The public key of the scheme is $(\mathbb{G}, g, q, x)$, and the secret key is $(\mathbb{G}, g, q, x)$.

    Given a uniformly random $r\in\mathbb{Z}$, we define the encryption $\Enc_r:\mathbb{G}\rightarrow\mathbb{G}\times\mathbb{G}$ of a message $m$ to be
    
    $$\Enc_r(m) = (g^r, m\cdot h^r)$$

    We define the decryption $\Dec:\mathbb{G}\times\mathbb{G}\rightarrow \mathbb{G}$ of a ciphertext $(c_1, c_2)$ to be
    
    $$\Dec(c_1,c_2)=c_2\cdot c_1^{-x}$$

    If $(c_1,c_2)$ is an encryption of $m$ then $c_2\cdot c_1^{-x}=m\cdot g^{rx}\cdot g^{-rx}=m$.
\end{definition}
It is not immediately clear that such a group, its operations, and an appropriate $g$ can be efficiently computed. Appendix~\ref{app-elgamal} expands on the relevant mathematical details.

The ElGamal cryptosystem is at the heart of the protocol, used both to preserve voters' privacy as well as to ensure the electoral commission's integrity. Usefully, the construction of ElGamal makes it easy to produce \textit{proofs} of statements about its ciphertexts (such as whether they decrypt to what they are supposed to); this is used heavily in the protocol.

\subsection{Security of ElGamal}
We will use a standard definition of security based on \textit{indistinguishability}: an adversary should not be able to tell the difference between any two ciphertexts. The goal is to show that an adversary cannot run a \textit{chosen plain text attack} (CPA), where by encrypting known messages, they can learn information about an unknown ciphertext. Clearly if the adversary can decrypt without the key, they can succeed at this attack; by contraposition, an adversary who cannot succeed at this attack cannot succeed at general decryption.

\begin{definition}[IND-CPA secure]
    Given a public key cryptosystem $\Pi$ with security parameter $lambda$, consider the game $G_{\text{IND-CPA}}^{\Pi,\lambda}$ between adversary $\mathcal{A}$ and challenger $\mathcal{C}$:
    \begin{enumerate}
        \item $\mathcal{C}$ runs $\mathsf{Gen}(\lambda)$ computes public and secret keys $(pk, sk)$ and sends $pk$ to $\mathcal{A}$. $\mathcal{C}$ provides $\mathcal{A}$ with oracle access to $\Enc_{pk}$.
        \item $\mathcal{A}$ sends a pair of messages $m_0, m_1$ to $\mathcal{C}$.
        \item $\mathcal{C}$ chooses a random bit $b$, and the ciphertext $\Enc_{pk}(m_b)$ is computed and sent to $\mathcal{A}$.
        \item $\mathcal{A}$ outputs a bit $b^*$.
    \end{enumerate}
    $\mathcal{A}$ wins if $b^*=b$. If for all PPT adversaries $\mathcal{A}$
    $$\Adv\left(\mathcal{A},G^{\Pi,\lambda}_{\text{IND-CPA}}\right)=\negl(\lambda)$$
    we say $\Pi$ is \textit{IND-CPA secure} (indistinguishable-chosen plaintext attack secure).
\end{definition}
A proof that ElGamal satisfies this property is provided in Appendix~\ref{app-elgamal}.
\subsection{Zero-knowledge proofs}
A \textit{zero-knowledge proof} addresses a situation where one party, the \textit{prover}, knows a secret (e.g. the solution to an equation) and wishes to demonstrate this knowledge to the other party, the \textit{verifier}. We will make extensive use of zero-knowledge proofs to demonstrate that the electoral commission and the trustees do not attempt to cheat the election.

Zero-knowledge proofs rely on three key properties:
\begin{enumerate}
    \item \textit{completeness}: if the prover honestly knows the secret, they must be able to construct a valid proof.
    \item \textit{soundness}: a prover who does not know the secret must not be able to construct a valid proof, except with negligible probability
    \item \textit{zero-knowledge}: an eavesdropper must learn nothing apart from that the prover knows a secret satisfying the required conditions
\end{enumerate}
We will also typically require our zero-knowledge proofs are \textit{universally verifiable}, meaning that any observer (e.g. a voter) can verify the correctness of the proofs.

We formulate a zero-knowledge proof as a protocol where the prover and verifier exchange messages, and the verifier either accepts or rejects the proof. The prover and verifier may either be honest (meaning they correctly follow the protocol), or dishonest (meaning they deviate from the protocol). The treatment that follows is based on that of~\cite{boneh2020graduate}.

The prover will construct a \textit{proof} of some \textit{statement} $y$ from a set of statements $\mathcal{Y}$. We formalise what it means for a statement to be true:
\begin{definition}
    Let $\mathcal{R}\subseteq\mathcal{X}\times\mathcal{Y}$ be an \textit{efficiently recognisable} relation; that is, there exists a polynomial-time algorithm that decides $\mathcal{R}$.
    \begin{itemize}
        \item A statement $y\in\mathcal{Y}$ is a \textit{true statement} if there exists a \textit{witness} $x\in\mathcal{X}$ such that $(x, y)\in\mathcal{R}$. Otherwise, $y$ is a \textit{false statement}.
        \item The \textit{language defined by} $\mathcal{R}$ is the set of true statements
        $$L_\mathcal{R}=\{y\in\mathcal{Y}\ |\ \exists\, x\in\mathcal{X}\text{ s.t. }(x,y)\in\mathcal{R}\}$$
    \end{itemize}
\end{definition}
For example, one may wish to prove they know the discrete logarithm of $y=g^x$; the statement would be $(y, g)\in\mathcal{Y}$ with witness $x$. The zero-knowledge proofs we use take the below form:
\begin{definition}[$\Sigma$-protocol]
    A $\mathit{\Sigma}$\textit{-protocol} for an efficiently recognisable relation $\mathcal{R}\subseteq\mathcal{X}\times\mathcal{Y}$ and a finite \textit{challenge space} $\mathcal{C}$ is two interactive PPT algorithms: a prover $P$ that takes as input $(x, y)\in\mathcal{R}$, and a verifier $V$ that is given $y$. They engage in the following interaction:
    \begin{enumerate}
        \item $P$ chooses a \textit{commitment} $t$ (from any set) and sends it to $V$.
        \item $V$ chooses a \textit{challenge} $c\in\mathcal{C}$ and sends it to $P$.
        \item $P$ computes a \textit{response} $z$ and sends it to $P$.
        \item $V$ deterministically outputs either $\mathsf{accept}$ or $\mathsf{reject}$, using only the statement $y$ and the \textit{conversation} $(t, c, z)$
    \end{enumerate}
    We require a $\Sigma$-protocol to be \textit{complete}: for all $(x, y)\in\mathcal{R}$, given an honest prover $P(x, y)$, $V(y)$ must always output $\mathsf{accept}$.
\end{definition}
We now define the other key properties of a zero-knowledge proof.

It is not immediately clear what it means for a computer or an algorithm to ``know'' something. The standard approach is to construct an \textit{extractor} algorithm that, given two accepting conversations with the same commitment, can deterministically calculate the secret. To make use of this, we will imagine that we can run the protocol, and then ``rewind'' $P$ to the step just before it received the challenge. We will then give it a \textit{different} challenge. If the challenge space $\mathcal{C}$ is large and $V$ accepts both conversations with non-negligible probability, then we can be confident that $P$ knows the witness --- or at the very least is capable of efficiently computing it. Otherwise, $P$ has been very lucky indeed to be able to answer both challenges correctly.
\begin{definition}(Knowledge soundness)
    A $\Sigma$-protocol satisfies \textit{knowledge soundness} if there is a polynomial-time \textit{extractor} algorithm $\mathsf{Ext}$ that, given a statement $y\in\mathcal{Y}$ and two accepting conversations with the same commitment $(t, c, z)$ and $(t, c', z')$, outputs a witness $x\in\mathcal{X}$ such that $(x, y)\in\mathcal{R}$.
\end{definition}

The standard definition of zero-knowledge is a little subtle. The idea is to show there is a simulator that could produce an accepting conversation. Then an adversary learns nothing from eavesdropping on (or participating in) the conversation --- since they could have just simulated it instead.
\begin{definition}[Special honest verifier zero knowledge]
    A $\Sigma$-protocol is \textit{special honest verifier zero knowledge} if there exists a PPT \textit{simulator} algorithm $\Sim$ such that:
    \begin{enumerate}
        \item for all inputs $(y, c)\in\mathcal{Y}\times\mathcal{C}$, $\mathsf{Sim}$ outputs $(t, z)$ such that $(t, c, z)$ is an accepting conversation for $y$
        \item for all $(x, y)\in\mathcal{R}$, if we choose $c\leftarrow\mathcal{C}$ and $(t, z)\leftarrow\mathsf{Sim}(y, c)$ uniformly at random, then $(t, c, z)$ has the same distribution as conversations between $P(x, y)$ and $V(y)$.
    \end{enumerate}
\end{definition}
Note that condition 1 requires the simulator to always produce an accepting conversation, \textbf{even for a false statement}. Condition 2 requires the simulated conversations to be indistinguishable from real conversations.

It is counter-intuitive that we may assume the verifier is honest; what is the use of zero-knowledge if a cheating verifier can cause a prover to leak information? However, it is possible to transform the \textit{interactive} protocols we will discuss into \textit{non-interactive} protocols -- that is, protocols where the verifier and prover are the same party -- using the \textit{Fiat-Shamir heuristic}, discussed in more detail in Appendix~\ref{app-proof}. Because of this, honest verifier zero knowledge is strong enough for most applications.

Example definitions of each of the zero-knowledge proofs we use in the protocol appear in Appendix~\ref{app-proof}.

% TODO: non-malleability
\section{The protocol}\label{sec-protocol}
\subsection{Overview}
At a high level, the protocol pairs each vote with a MAC that prevents tampering. Each vote is paired with secret numbers that uniquely determine a given vote's MAC. A commitment is made to these secrets, as well as the encrypted vote and MAC, and the secrets are sent encrypted with the vote; this allows the electoral commission to check the commitments and match the votes to their MAC. A series of verifiable shuffle procedures ensure that the link between votes and voter IDs is destroyed for anybody who does not hold the ElGamal private key.
\subsection{Setup}
Before any voter can cast a vote, some public parameters must be established. Choose $n$ electoral trustees, who should be mutually distrusting; good candidates include state electoral commissions and representatives from major parties. Generate an exponential ElGamal key-pair $(pk, sk)$ shared among the $n$ trustees such that any $k$ of them can decrypt a given ciphertext. Also generate public parameters $(G, H, P)$ of a Pedersen commitment scheme.

Each voter should be assigned a unique ID number; the voter should have some assurance that their ID number is indeed unique. This assignment does not have to remain secret, and the electoral commission should be able to identify voters by their ID. An append-only web bulletin board should be online and accessible to all parties.
\subsection{Casting a ballot}
Before creating a ballot, the voter's device must choose secret parameters that will be used to generate a MAC. It should choose $a,b,r_a,r_b$ uniformly at random from the ElGamal group, and post
$$\big(\VoterID,\ \commit(a;r_a),\ \commit(b;r_b)\big)$$
to the WBB, committing to its parameters.

To create the ballot, the voter enters their vote on the device, which is encoded as a number $\Vote$. The device calculates $\Mac=a\cdot \Vote+b$, and sends (e.g. via the Internet)\footnote{We assume for ease of exposition that this Internet connection is untappable. In practice, this is not really the case, and defences against this are an open question.}
$$\left(\VoterID,\ \{\Vote\}_{pk},\ \{\Mac\}_{pk}\right), \PrfKnow(\{\Vote\}_{pk}, \PrfKnow(\{\Mac\}_{pk}))$$
to the electoral commission. The electoral commission checks the proofs (to ensure the device did not simply send random values), re-randomises the encryptions, and posts the result to the WBB, effectively committing to a vote and its corresponding MAC. Once the device verifies its ID has an encrypted vote and MAC on the WBB, it produces a printed ballot with two separate pieces of paper
$$\Paper_1 = \left(\Vote,\ \{a,b,r_a,r_b\}_{pk}, \PrfKnow(\{a,b,r_a,r_b\}_{pk})\right)$$
$$\Paper_2 = \left(\VoterID, \{\VoterID\}_{pk}, \PrfEnc(\VoterID, \{\VoterID\}_{pk})\right)$$
The idea of Paper 2 is to prove to the electoral commission that the voter ID on the ballot is that of the correct voter without allowing a worker who performs this check to see the vote (thereby breaking privacy).

After doing this, the voter can simply mail their paper ballot to the electoral commission, providing whatever identification details are usual in their jurisdiction (e.g. writing their name and address on the envelope).
\subsection{Tallying ballots}
Once the ballot casting period has ended, the electoral commission can begin receiving ballots. The voter ID as seen by the electoral commission is referred to as $\receivedvid$. First, the electoral commission checks the proof on Paper 2. 
They should also confirm that $\receivedvid$ matches the identification on the outside of the envelope. If it does, they should attach the encryption $\{\receivedvid\}_{pk}$ to Paper 1 (without opening it)\footnote{This could be done by e.g. tearing Paper 2 and stapling it to Paper 1, or even by providing $\{\receivedvid\}_{pk}$ on a third piece of paper.}, and destroy the rest of Paper 2. The set of Paper 1s from all ballots should now be shuffled physically, to preserve privacy.

After shuffling, the electoral commission receives Paper 1 as
$$\Paper_1=\left(ReceivedVote,\ \{a,b,r_a,r_b\}_{pk}, \PrfKnow(\{a,b,r_a,r_b\}_{pk}\right)$$
The electoral commission should check the proofs, and if they are valid, post the re-randomised received ballot to the WBB. This should be performed under scrutiny from e.g. party representatives to ensure they are faithfully posted; this is the only step that needs active scrutiny.

The electoral trustees next perform a cryptographic mix to produce a list of ballots of the form
$$\left(\{ReceivedVote\}_{pk},\ \receivedvid,\ (a,b,r_a,r_b)\right)$$
on the WBB. The resulting list should be joined to the commitments on the WBB by matching $ReceivedVoterID$ to $\VoterID$, producing a list of tuples
$$\left(\{ReceivedVote\}_{pk},\ \VoterID,\ (a,b,r_a,r_b), \commit(a;r_a), \commit(b;r_b)\right)$$
If there are multiple tuples for some $\VoterID$, for each tuple the pair of commitments $\commit(a;r_a)$, $\commit(b;r_b)$ should be checked. If the parameters $a,b,r_a,r_b$ are correct openings for exactly one tuple, only that tuple should be accepted; in any other case, no tuples for $\VoterID$ should be accepted.

The accepted tuples should then be matched with the electoral commission's commitments to produce a list of tuples
$$\left(\{\Vote\}_{pk},\{\Mac\}_{pk}, \{ReceivedVote\}_{pk},\ \VoterID,\ a, \{b\}_{pk}, \PrfEnc(b, \{b\}_{pk})\right)$$
For all accepted tuples, the electoral trustees should perform a plaintext equivalence test on the WBB to show whether $ReceivedVote=\Vote$ (without decrypting either). If this succeeds, using the homomorphic property of exponential ElGamal the electoral commission\footnote{This does not require the secret key, so it can be easily verified by any party.} constructs a second MAC from the received vote:
$$\{\Mac'\}_{pk}=a\cdot\{ReceivedVote\}_{pk}+\{b\}_{pk}$$
This is posted to the WBB with the voter ID and the committed vote-MAC pair:
$$\left(\VoterID, \{\Vote\}_{pk},\ \{\Mac\}_{pk},\ \{\Mac'\}_{pk}\right)$$
The electoral trustees perform another plaintext equivalence test on the WBB to show that $\Mac=\Mac'$. For all tuples that pass this test, the electoral trustees should decrypt $\{\Vote\}_{pk}$ to produce a final list of valid votes. (We assume that once the final list is public, someone counts the votes correctly.)

Note that anybody can check whether a given voter ID produced a valid vote by seeing whether a tuple $\left(\VoterID, \{\Vote\}_{pk},\ \{\Mac\}_{pk},\ \{\Mac'\}_{pk}\right)$ passed the final plaintext equivalence test, providing \textit{individual} verifiability. It is easy to modify the protocol to remove this property, instead providing \textit{group} verifiability; this may be desirable depending on the application.
\subsection{Verification procedure}
We provide a summary of the various checks that need to be performed to verify the election. Verification is broken into three separate domains. Each voter must check the paper printout herself, and whether her ID appears in the final mix. Scrutineers from third parties must observe the process of receiving paper ballots. Finally, the WBB transcript can in theory be verified by anyone; because this may not be a trivial computational task, we expect that trusted entities such as media organisations would perform verification of this transcript on the behalf of voters.

\textbf{By the voter}
Before sending their vote by mail, the voter should check that the printed ballot paper matches the vote they intend to cast. Once the receiving process is complete, if the voter wishes, they can check whether their voter ID passed the verifications and plaintext equivalence tests on the WBB; if it did not, their vote was not accepted.

\textbf{By election scrutineers}
Scrutineers that are present when the received envelopes are opened must check:
\begin{enumerate}
	\item that the received voter ID matches the entry on the electoral roll;
	\item that the proof of encryption on Paper 2 is correct;
	\item that Paper 2 was correctly attached to Paper 1; and
	\item that the vote posted to the WBB matches the vote on Paper 1.
\end{enumerate}

\textbf{Of the WBB}
To ensure correctness of the WBB transcript, any third party (optionally including voters) should check:
\begin{enumerate}
	\item the first mix and decryption proofs
	\item that the claimed commitment openings are correct openings
	\item that there is exactly one correct commitment opening for each accepted voter ID
	\item that $\receivedvid$ and $\VoterID$ are correctly joined to the MAC and vote committed to by the EC
	\item that $\receivedvid = \VoterID$ for each row
	\item any provided proofs of plaintext equality
	\item that only votes that pass the plaintext equality tests are included in the final stage
	\item the final mix and decryption proofs
\end{enumerate}
One of the great challenges in paper elections is \textit{chain-of-custody}: once a paper ballot is filled out by a voter, it should never leave the sight of a trusted authority. Traditional postal voting breaks this requirement, as postal channels are demonstrably vulnerable to interception~\cite{stewart2010losing}. To address this issue, our protocol defines a weaker trust model than the traditional chain of custody. The protocol is verifiable as long as at least one of the below is honest:
\begin{itemize}
    \item the client's device
    \item the postal channel \textit{and} the Electoral Commission
\end{itemize}
Thus an adversary can undetectably cheat the election if they control both the device and the postal channel (and/or the Electoral Commission), but cannot win if they control only one. This seems to be a reasonable compromise, since if the Electoral Commission (or postal service) deliberately compromises voters' devices, this is indicative of systemic corruption that no voting scheme can address.
\section{Properties and trust assumptions}\label{sec-properties}
The standard approach to proving desirable properties of cryptographic protocols is to define a \textit{game} between an adversary and a challenger, and to argue that the adversary can win only if they are very lucky. This is made formal below.
\begin{definition}[Negligible function]
    A function $f:\mathbb{N}\rightarrow\mathbb{R}$ is \textit{negligible} if for all polynomials $\poly(x)$, there exists $N>0$ such that for all $x>N$

    $$|f(x)|<\frac{1}{\poly(x)}$$

    We will write $\Pr[A]=\negl(\lambda)$ as shorthand to mean ``there exists a negligible function $\negl$ such that $\Pr[A]=\negl(\lambda)$''.
\end{definition}
Our adversary then should only be able to win the game with a negligible probability as a function of some security parameter. To formally define what we mean by ``adversary'':
\begin{definition}[Probabilistic polynomial-time (PPT) adversary]
    A \textit{probabilistic polynomial-time adversary} (denoted $\mathcal{A}$) is an algorithm (typically interactive) that runs in polynomial time and has access to a randomness source.
\end{definition}
Many of the games we will use involve the adversary choosing a bit; it follows that the adversary can always win with at least 50\% probability, so we will instead talk about a negligible \textit{advantage} over tossing a coin. 
\begin{definition}[Advantage]
    An adversary $\mathcal{A}$ has \textit{advantage} $\varepsilon$ in game $G$ if
    $$\Pr\left[\mathcal{A}\text{ wins }G\right]=\varepsilon$$
    We will write $\Adv(\mathcal{A}, G)=\varepsilon$.

    Given two games $G_i, G_j$, we say $\mathcal{A}$'s \textit{advantage between} the two games is
    $$\Adv_{G_i, G_j}(\mathcal{A}) = \frac{1}{2}
    \Big|
        \Adv(\mathcal{A}, G_i)
         -
        \Adv(\mathcal{A}, G_j)
    \Big|$$
\end{definition}
\subsection{Privacy}
Our definition of privacy is based on that of~\cite{kiayias2015end}; however, we separate \textit{voter privacy} for \textit{receipt freeness} because we can prove privacy against a stronger adversary than for receipt freeness. For privacy, we will remove the simulator defined by~\cite{kiayias2015end} --- the purpose of the simulator is to allow a voter to lie about their vote, which is not relevant in the privacy-only case.

Voter privacy is defined as a game between a PPT adversary $\mathcal{A}$ and a challenger $\mathcal{C}$. We consider a set of $m$ candidates $\mathcal{P}=\{P_1,\ldots,P_m\}$, a set of $n$ voters $\mathcal{V}=\{V_1,\ldots,V_n\}$, a set of allowed candidate selections (votes) $\mathcal{U}$ and an \textit{election evaluation function} $f(\langle \mathcal{U}_1,\ldots,\mathcal{U}_n \rangle)$ mapping the voters' candidate selections to a vector where the $i$th index contains the number of votes for candidate $\mathcal{P}_i$. The general idea is that the adversary chooses the parameters for the election and may choose to \textit{corrupt} a number of voters of its choice, meaning that it acts as the voter. The challenger acts as the EC, WBB, and election trustees, and acts on behalf of non-corrupted voters; for each non-corrupted voter, the adversary provides the challenger with two votes to choose from. The adversary wins if it is able to guess which of the two votes the non-corrupted voters cast \textbf{and} the adversary did not choose the parameters so that it always wins. An in-depth discussion of this second condition follows the formal definition below.

\begin{definition}[Voter privacy]
    Consider the below game, written $G^\mathcal{A}_{\text{priv}}(1^\lambda, n, m)$.
    \begin{enumerate}
        \item Given parameters $1^\lambda, n, m$, $\mathcal{A}$ generates a set of candidates $\mathcal{P}=\{P_1,\ldots,P_m\}$, voters $\mathcal{V}=\{V_1,\ldots,V_n\}$, and allowed candidate selections $\mathcal{U}$ (which may be a single choice, or a numbered preference list, or whatever is appropriate). It sends the sets $\mathcal{P}, \mathcal{V},$ and $\mathcal{U}$ to $\mathcal{C}$.
        \item $\mathcal{C}$ tosses a coin $b\in\{0, 1\}$, and runs the $\mathsf{Setup}$ protocol to obtain the parameters for ElGamal encryption and Pedersen commitment. It sends the public parameters to $\mathcal{A}$.
        \item $\mathcal{A}$ schedules the $\mathsf{Cast}$ protocol for all voters, which are allowed to run concurrently. For all $V_l\in\mathcal{V}$, the adversary chooses whether $V_l$ is to be corrupt.
        \begin{itemize}
            \item If $V_l$ is corrupt, $\mathcal{A}$ acts on $V_l$'s behalf as it wishes.
            \item If $V_l$ is not corrupt, $\mathcal{A}$ generates and sends two candidate selections $\mathcal{U}_l^0, \mathcal{U}_l^1$ to $\mathcal{C}$. It must do so such that $f(\langle\mathcal{U}_l^0\rangle_{V_l\in \tilde{\mathcal{V}}})=f(\langle\mathcal{U}^1_l)_{V_l\in \tilde{\mathcal{V}}}\rangle`$ where $\tilde{\mathcal{V}}$ is the set of honest voters (that is, the set of honest votes alone does not leak $b$).
			
			\hspace{0.25in}$\mathcal{C}$ acts on $V_l$'s behalf to cast the vote $\mathcal{U}_l^b$. During this process $\mathcal{A}$ may view the encrypted data $\{\Vote\}_{\mathit{pk}}, \{\Mac\}_{\mathit{pk}}$ in transit to the EC, as well as the WBB and $\Paper_1, \Paper_2$ (after shuffling).
        \end{itemize}
        \item $\mathcal{C}$ runs the $\mathsf{Tally}$ protocol, acting as the EC, the trustee set $T$, and the WBB. $\mathcal{A}$ may continue to observe the WBB.
        \item $\mathcal{A}$ outputs a bit $b^*$.
    \end{enumerate}
    $\mathcal{A}$ wins the game if and only if $b=b^*$. A scheme achieves \textit{voter privacy} if for all PPT adversaries $\mathcal{A}$
    $$\Adv\left(G^\mathcal{A}_{\text{priv}}(1^\lambda, n, m)\right)=\negl(\lambda)$$
\end{definition}
This definition contains some very careful phrasing. Note first what the adversary is allowed to learn: it can see anything on the WBB, anything on $\Paper_2$ for all voters, anything on $\Paper_1$ for all voters (but \textbf{not} which $\Paper_2$ corresponds to it for honest voters), and any of the encrypted data sent to the EC (but \textbf{not} an honest voter's view of how it was constructed). This is more general than what we will allow for receipt-freeness.

It is worth discussing some details in the condition placed on the adversary's choice of candidate selections in step 3. This prevents any attempt by the adversary to trivialise the problem by forcing the election's outcome alone to reveal $b$, and in particular prevents the adversary choosing all but one voter to be corrupt --- since the list of decrypted votes on the WBB would reveal the cast vote. This is important since the protocol reveals not only the winner of the election, but also a full list of all valid votes.

A proof that our scheme satisfies this property follows. The goal will be to sequentially alter the privacy game, where each step is negligibly distinguishable from the previous step so that the adversary does not notice the manipulations. We will arrive at a game where none of the ciphertexts contain any information, so the adversary has no hope of winning.

\begin{theorem}\label{thm-privacy}
    For all constants $m \in \mathbb{N}$ and $n=poly(\lambda)$, the voting system described in Section~\ref{sec-protocol} satisfies voter privacy.
\end{theorem}
\begin{proof}
    We will use a hybrid argument to construct a sequence of games until we arrive at one in which the adversary clearly cannot have any advantage.
    \begin{itemize}[leftmargin=4em]
        \item[Game] $G_0$: the unaltered game $G^\mathcal{A}_{\text{priv}}(1^\lambda, n, m)$. By definition $\Adv_{G_0, G^\mathcal{A}_{\text{priv}}(1^\lambda, n, m)}(\mathcal{A})=0$.
        
        \item[Game] $G_1$: the same as Game $G_0$, except the decryption and plaintext equivalence tests on the WBB are generated using knowledge of their plaintexts; this is possible since every ciphertext is either generated by the challenger, or is generated by the adversary with an accompanying ZKP proving knowledge (so the challenger can use the corresponding zero-knowledge extractor). The soundness error in the adversary's ZKPs gives $\Adv_{G_1, G_0}(\mathcal{A})=\negl(\lambda)$.
 
        \item[Game] $G_2$: the same as Game $G_1$, except the ZKPs used to prove correctness of the decryptions and PETs are simulated via the zero-knowledge simulator. The ZKPs are non-malleable and the WBB filters for duplicates, so the adversary's proofs cannot depend on the simulated proofs --- we are therefore still able to use the extractor from Game $G_1$. Note that the challenger no longer uses the ElGamal secret key for any purpose. The simulator has no error, so $\Adv_{G_2, G_1}(\mathcal{A})=0$.
 
        \item[Game] $G_3$: the same as Game $G_2$, except the mixing proofs are also simulated via the zero-knowledge simulator to ensure no information about the permutation or randomness used is leaked. As in $G_2$, we have $\Adv_{G_3, G_2}(\mathcal{A})=0$.
        
        \item[Game] $G_4$: the same as Game $G_3$, except the ciphertexts are replaced with encryptions of random values from an oracle (and re-randomisations are replaced with fresh encryptions of random values). No ciphertexts are ever decrypted,\footnote{If we did decrypt ciphertexts, the adversary could learn the decryptions of certain ciphertexts and use this to undermine the IND-CPA property.} so we can use the IND-CPA property of ElGamal to guarantee that $\Adv_{G_4,G_3}(\mathcal{A})=\negl(\lambda)$ (because the adversary cannot tell the ciphertexts were replaced).
    \end{itemize}
    In Game $G_4$, the encryptions are random and contain no usable information, and the link between $\VoterID$ and $\Vote$ is destroyed by the mix, so the adversary cannot have any advantage in guessing which vote was cast by each voter. Therefore, $\Adv(\mathcal{A}, G_3)=0$, which implies $\Adv\left(G^\mathcal{A}_{\text{priv}}(1^\lambda, n, m)\right)=\negl(\lambda)$ as required.
\end{proof}
\subsection{Receipt-freeness}
The game used for receipt-freeness will be similar to the privacy game, with two key differences:
\begin{enumerate}
    \item The adversary's view is restricted to the WBB and the view of the voter's client (\textbf{not} the pieces of paper).
    \item The voter is allowed to \textit{simulate} their client's view with a simulator algorithm $\mathcal{S}$, claiming they voted differently to how they actually did.
\end{enumerate}

The goal will be to demonstrate that a voter can present a convincing argument that they voted differently to how they actually did. This protects the voter from coercion, but also prevents the voter selling her vote, as the buyer cannot tell whether or not the voter is being honest. We do not prove this for ``over-the-shoulder'' coercion, so an adversary who watches the voter seal and post her envelope can be certain how she voted. A formal definition follows.
\newpage
\begin{definition}[Receipt-freeness]
    Consider the below game, written $G_{\text{RecFree}}^{\mathcal{A},\mathcal{S}}(1^\lambda, n, m)$.
    \begin{enumerate}
        \item Given parameters $1^\lambda, n, m$, $\mathcal{A}$ generates a set of candidates $\mathcal{P}=\{P_1,\ldots,P_m\}$, voters $\mathcal{V}=\{V_1,\ldots,V_n\}$, and allowed candidate selections $\mathcal{U}$. It sends the sets $\mathcal{P}, \mathcal{V},$ and $\mathcal{U}$ to $\mathcal{C}$.
        \item $\mathcal{C}$ tosses a coin $b\in\{0, 1\}$, and runs the $\mathsf{Setup}$ protocol to obtain the parameters for ElGamal encryption and Pedersen commitment. It sends the public parameters to $\mathcal{A}$.
        \item $\mathcal{A}$ schedules the $\mathsf{Cast}$ protocol for all voters, which are allowed to run concurrently. For all $V_l\in\mathcal{V}$, the adversary chooses whether $V_l$ is to be corrupt.
        \begin{itemize}
            \item If $V_l$ is corrupt, $\mathcal{A}$ acts on $V_l$'s behalf as it wishes.
            \item If $V_l$ is not corrupt, $\mathcal{A}$ generates and sends two candidate selections $\mathcal{U}_l^0, \mathcal{U}_l^1$ to $\mathcal{C}$. It must do so such that $f(\langle\mathcal{U}_l^0\rangle_{V_l\in \tilde{\mathcal{V}}})=f(\langle\mathcal{U}^1_l)_{V_l\in \tilde{\mathcal{V}}}\rangle`$ where $\tilde{\mathcal{V}}$ is the set of honest voters (that is, the set of honest votes alone does not leak $b$).
			
			\hspace{0.25in}$\mathcal{C}$ acts on $V_l$'s behalf to cast the vote $\mathcal{U}_l^b$. During this process $\mathcal{A}$ may view \textbf{only} the WBB. After $\mathsf{Cast}$ terminates, $\mathcal{C}$ provides to $\mathcal{A}$:
            \begin{enumerate}
                \item the \textit{receipt} consisting of voter $V_l$'s $\VoterID$
                \item if $b=0$, $V_l$'s real view (including randomness for the encryptions)
                \begin{gather*}
                    a, b, r_a, r_b, \Vote=\mathcal{U}^0_l, \Mac,\\\{g^\Vote\}_{pk}, \{g^\Mac\}_{pk}, \{a,b,r_a,r_b\}_{pk},\{\VoterID\}_{pk}
                \end{gather*}
                If $b=1$, $\mathcal{C}$ instead provides a simulated view using $\mathcal{S}$.
            \end{enumerate}
        \end{itemize}
        \item $\mathcal{C}$ runs the $\mathsf{Tally}$ protocol, acting as the EC, the trustee set $T$, and the WBB. $\mathcal{A}$ may continue to observe the WBB.
        \item $\mathcal{A}$ outputs a bit $b^*$.
    \end{enumerate}
    $\mathcal{A}$ wins the game if and only if $b=b^*$. A scheme achieves \textit{receipt freeness} if there exists a simulator $\mathcal{S}$ such that for all PPT adversaries $\mathcal{A}$
    $$\Adv\left(\mathcal{A}, G^{\mathcal{A},\mathcal{S}}_{\text{RecFree}}(1^\lambda, n, m)\right)=\negl(\lambda)$$
\end{definition}

We will prove this property by having the electoral commission secretly swap the coerced voters' encrypted data so that the mixing and decryption falsely proves they obeyed the adversary, and argue that an adversary cannot tell the difference. The voter $V_l$ will be asked to vote according to the selection $\mathcal{U}^0_l$, but will actually vote according to $\mathcal{U}^1_l$. She will tell the truth about her secrets $a, b, r_a, r_b$, but will claim to have sent the MAC $a\cdot\mathcal{U}^0_l+b$ instead of the MAC corresponding to her vote. The adversary cannot watch the electoral commission randomising the MAC, so cannot tell the difference. Swapping the encrypted data received in the post will allow the EC to prove plaintext equivalence of the encrypted data and the claimed vote.
\begin{theorem}\label{thm-recfree}
    For all constants $m \in \mathbb{N}$ and $n=poly(\lambda)$, the voting system described in Section~\ref{sec-protocol} satisfies receipt freeness.
\end{theorem}
\begin{proof}
    First, we define the simulator. $\mathcal{S}$ receives an honest voter's view
    \begin{gather*}
        a, b, r_a, r_b, \Vote=\mathcal{U}^1_l, \Mac,\\\{g^\Vote\}_{pk}, \{g^\Mac\}_{pk}, \{a,b,r_a,r_b\}_{pk},\{\VoterID\}_{pk}
    \end{gather*}
    It computes a valid MAC for the claimed vote $\mathcal{U}^0_l$ as well as ciphertexts for the claimed vote and MAC. It then outputs the simulated view
    \begin{gather*}
        a, b, r_a, r_b, \Vote'=\mathcal{U}^0_l, \Mac'=a\cdot\Vote'+b\,\\\{g^{\Vote'}\}_{pk}, \{g^{\Mac'}\}_{pk}, \{a,b,r_a,r_b\}_{pk},\{\VoterID\}_{pk}
    \end{gather*}

    We will use a hybrid argument to prove the result as per Theorem~\ref{thm-privacy}.
    \begin{itemize}[leftmargin=4em]
        \item[Game] $G_0$: The actual game $G^{\mathcal{A},\mathcal{S}}_{RecFree}(1^\lambda,n,m)$, where the challenger uses $\mathcal{U}^b_l$ in the \textit{Cast} protocol and the above simulator is invoked when $b=1$.  (That is, voters vote as they wish and run the coercion-resistance strategy.)
        
        By definition $\Adv_{G_0,G^{\mathcal{A},\mathcal{S}}_{\text{RecFree}}(1^\lambda,n,m)}(\mathcal{A}) = 0$.
    
        \item[Game] $G_1$: The same as Game $G_0$, except the decryptions and plaintext equivalence tests are simulated with knowledge of the plaintext as in Theorem~\ref{thm-privacy}; $\Adv_{G_1, G_0}(\mathcal{A})=\negl(\lambda)$.
    
        \item[Game] $G_2$: The same as Game $G_1$, except the proofs used to demonstrate correct decryption and plaintext equivalence are simulated with their zero-knowledge simulators as in Theorem~\ref{thm-privacy}. We then have $\Adv_{G_2, G_1}(\mathcal{A})=0$.
 
        \item[Game] $G_3$: The same as Game $G_2$, except the proof of correct mixing is simulated as in Theorem~\ref{thm-privacy}. To ensure the link between successive ciphertexts is destroyed, the challenger uses knowledge of the plaintext to replace ciphertexts with fresh encryptions after each mix. We have $\Adv_{G_3, G_2}(\mathcal{A})=0$.
    
        \item[Game] $G_4$: The same as Game $G_3$, except when $b = 1$:
        \begin{enumerate}
            \item In Step ? of \textit{Cast}, the challenger posts an encryption of the claimed MAC, $\{g^{\Mac'}\}_{pk}$, instead of a re-randomised encryption of the actual MAC $\{g^\Mac\}_{pk}$.
            \item In Step ? of \textit{Tally}, the challenger changes the posted (re-randomised) encryptions of $\receivedvid$ and $a, b, r_a, r_b$ so that they appear together with the votes they claimed to have cast.
        \end{enumerate}
        \textit{Tally} can then proceed as usual; we have changed the votes and MACs consistently so that they are still plaintext-equivalent. Since all we have done is change encryptions for which the adversary does not know the randomness and the link between successive ciphertexts is destroyed, the IND-CPA property of ElGamal yields $\Adv_{G_4, G_3}(\mathcal{A})=\negl(\lambda)$.
    
        \item[Game] $G_5$: The same as Game $G_4$, except the challenger (acting as the honest voters) ignores the value of $b$ and always obeys the adversary. Since the adversary does not see anything different to what it saw in Game $G_4$, $\Adv_{G_5, G_4}(\mathcal{A})=0$.
    \end{itemize}
    The adversary can have no advantage in Game $G_5$ because the value of $b$ is ignored. Following the chain of games then yields
        $$\Adv_{G_5, G^{\mathcal{A},\mathcal{S}}_{RecFree}(1^\lambda,n,m)}=negl(\lambda)$$
    as required.
\end{proof}

\subsection{Verifiability for a cheating EC}
\subsection{Verifiability for a cheating client}
\section{Conclusion}
\newpage
\section{References}
\bibliographystyle{unsrt}
\bibliography{papers}
\newpage
%TC:ignore
\appendix
\section{ElGamal encryption}\label{app-elgamal}
\subsection{Choosing an appropriate group}
Recall from Definition~\ref{def-elgamal} that we need a group $\mathbb{G}$ with an element $g\in\mathbb{G}$ of order $q$. We will need a prime number of a particular form to produce our group.
\begin{definition}[Safe prime]
    A prime $p$ is \textit{safe} if $p=2q+1$ for some other (large) prime $q$.
\end{definition}
Let $\mathbb{G}=\mathbb{Z}^\times_p$ be the multiplicative group of integers modulo a safe prime $p=2q+1$. We first demonstrate that this is a cyclic group of order $p-1=2q$. The proof is due to \cite{cyclicity}.
\begin{lemma}\label{lem-order-divides}
    Let $G$ be a finite Abelian group, and $n$ be the maximal order among elements of $G$. Then for all $g\in G$, the order of $g$ divides $n$.
\end{lemma}
\begin{proof}
    Let $g\in G$ have the maximal order $n$. Let $h\in G$ with order $m$. Suppose by way of contradiction that $m$ does not divide $n$. Then there is some prime $p$ with a power in $m$ greater than its power in $n$. Let $p^e$ be the greatest power of $p$ in $m$ and $p^f$ be the greatest power of $p$ in $n$. Then $g^{p^f}h^{m/p^e}$ has order
    $$\frac{n}{p^f}p^e=np^{e-f}>n$$
    contradicting the maximality of $n$.
\end{proof}
\begin{lemma}
    $\mathbb{Z}^\times_p$ is cyclic with order $p-1$.
\end{lemma}
\begin{proof}
    Let $n\leq p-1$ be the maximal order among elements of $\mathbb{Z}^\times_p$. Every element has order $o\vert n$ by Lemma~\ref{lem-order-divides}, so for all $a\in\mathbb{Z}^\times_p$ we have $a^n=1$. This equation has at most $n$ solutions, and we have produced $p-1$ solutions already; therefore $p-1\leq n$.
    Combining the inequalities gives $n=p-1$, so we have an element of order $p-1=|\mathbb{Z}^\times_p|$ as required.
\end{proof}
Unfortunately $\mathbb{Z}^\times_p$ does not satisfy the decisional Diffie-Hellman (DDH) assumption, so we will not have the desired security properties:
\begin{lemma}\label{lem-parity}
    Let $g$ be a generator of $\mathbb{Z}^\times_p$ for a prime $p$. For all $x\in\mathbb{Z}^\times_p$, let $a=g^x$. Then $a^{\frac{p-1}{2}} = 1$ if and only if $x$ is even, and $a^{\frac{p-1}{2}} = -1$ if and only if $x$ is odd.
\end{lemma}
\begin{proof}
    Suppose $x$ is even; let $x=2y$. Then

    $$a^{\frac{p-1}{2}}=(g^x)^{\frac{p-1}{2}}=g^{2y\frac{p-1}{2}}=(g^{p-1})^y=1$$

    Suppose $x$ is not even; let $x=2y+1$. Then

    $$a^{\frac{p-1}{2}}=(g^x)^{\frac{p-1}{2}}=g^{(2y+1)\frac{p-1}{2}}=(g^{p-1})^yg^{\frac{p-1}{2}}=g^{\frac{p-1}{2}}\neq 1$$

    In particular $g$ is a generator so $g^\frac{p-1}{2}\neq 0$. By Fermat's little theorem we have $a^{p-1}=1$ or equivalently in the prime ring $\mathbb{Z}_p$

    $$\left(a^\frac{p-1}{2}-1\right)\left(a^\frac{p-1}{2}+1\right)\equiv 0\bmod p$$
    
    In the case under discussion, we are left with $a^\frac{p-1}{2}=-1$.
\end{proof}
\begin{theorem}
    $\mathbb{Z}^\times_p$ does not satisfy DDH.
\end{theorem}
\begin{proof}
    Let $g\in\mathbb{Z}^\times_p$ be a generator and $a,b\in\mathbb{Z}^\times_p$ be arbitrary. By Lemma~\ref{lem-parity}, $(g^a)^{\frac{p-1}{2}}=1$ if and only if $a$ is even, and similarly $(g^b)^{\frac{p-1}{2}}=1$ if and only if $b$ is even. So, given $g^a$ and $g^b$, we can determine the value of $\left(g^{ab}\right)^\frac{p-1}{2}$: it is 1 if and only if $a$ and $b$ are not both odd, and $-1$ otherwise. Thus we can distinguish $g^{ab}$ from $g^c$ for a random $c\in\mathbb{Z}^\times_p$.
\end{proof}
Happily, there is a \textit{subgroup} of $\mathbb{Z}^\times_p$ that is believed to satisfy DDH.
\begin{definition}[Quadratic residue]
    $a$ is a \textit{quadratic residue} mod $p$ if there exists $x\in\mathbb{Z}$ such that

    $$x^2=a\bmod p$$

\end{definition}
$\mathbb{Z}^\times_p$ has a subgroup of order $q$ (since $p-1=2q$). Euler's criterion tells us that there are $\frac{p-1}{2}=q$ quadratic residues modulo $p$, so we might hope that this subgroup is precisely the quadratic residues modulo $p$. For the below discussion, we assume that $p>3$.
\begin{lemma}
    The quadratic residues mod $p$ form a group under multiplication.
\end{lemma}
\begin{proof}
    Let $x^2,y^2\in\mathbb{Z}^\times_p$ be quadratic residues mod $p$. Then $x^2y^2=(xy)^2$ is also a quadratic residue, as is $(x^2)^{-1}=(x^{-1})^2$ (where $x^{-1}=x^{p-2}$). Associativity is automatic.
\end{proof}
\begin{lemma}
    The group of quadratic residues mod $p=2q+1$ is the subgroup of $\mathbb{Z}^\times_p$ of order $q$.
\end{lemma}
\begin{proof}
    Clearly $2^2$ is a quadratic residue and does not have order 2 or 1. ${2^2}^q=2^{2q}=2^{p-1}=1$ so it has order $q$, and thus generates the subgroup of order $q$.
\end{proof}
We therefore have a good candidate cyclic group for our ElGamal cryptosystem: choose a safe prime $p=2q+1$, and take the subgroup of $\mathbb{Z}^\times_p$ generated by $2^2$. In particular, every element is an even power of $g$, so Lemma~\ref{lem-parity} does not apply.

It remains to find a way to encode data as elements of this group; one possible choice is outlined below \cite{katz2014introduction}. Let $\mathbb{G}_p$ be the group of quadratic residues modulo a safe prime $p$.
\begin{theorem}
    Let $p$ be a safe prime congruent to 3 modulo 4 (so $p=4i+3$ for some $i\in\mathbb{Z}$).

    $$\pi:\mathbb{Z}_q\rightarrow\mathbb{G}_p,\ \pi(m)=(m+1)^2\bmod p$$

    is a bijection with inverse

    $$\pi^{-1}(x)=-1+\begin{cases}
        x^\frac{p+1}{4} & x^\frac{p+1}{4}\leq q\\
        -x^\frac{p+1}{4}&\text{otherwise}
    \end{cases}$$

\end{theorem}
\begin{proof}
    Note that $x^\frac{p-1}{2}=1$ by Lemma~\ref{lem-parity}, since $x$ is a quadratic residue. Then we have as one square root

    $$x=x^{\frac{p-1}{2}+1}=x^{2i+2}=(x^{i+1})^2=\left(x^\frac{p+1}{4}\right)^2$$

    To find the other square root:

    $$\left(p-x^\frac{p+1}{4}\right)^2=p^2-2px^\frac{p+1}{4}+x^\frac{p+1}{2}\equiv x^\frac{p+1}{2}\bmod p=x^{q+1}=x$$

    Since $q=\frac{p-1}{2}$ exactly one of these is less than or equal to $q$. The domain and codomain have the same cardinality, so the map is bijective.

    %For the isomorphism, we examine $\pi^{-1}(xy)$. The interesting case is when both $x^\frac{p+1}{4}>q$ and $y^\frac{p+1}{4}>q$; then

    %$$\left(p-x^\frac{p+1}{4}\right)\left(p-y^\frac{p+1}{4}\right)=p^2-py^\frac{p+1}{4}-px^\frac{p+1}{4}+(xy)^\frac{p+1}{4}\equiv p-(xy)^\frac{p+1}{4}\bmod p=\pi^{-1}(xy\right)$$

\end{proof}
\subsection{Security properties of ElGamal}
We will provide proofs that ElGamal has the standard security properties for public key cryptosystems (that is, that an adversary has only a small probability of successfully breaking the system). Definitions and proofs below are based on those in~\cite{katz2014introduction}.

We begin with a standard problem that is believed to be computationally difficult to solve (in some groups). We phrase the problem as a \textit{game} between an adversary and a challenger; we will demonstrate that an adversary has a negligible advantage over a coin toss in the game. Intuitively, the goal is to be able to distinguish between the triples $(g^a, g^b, g^{ab})$ and $(g^a, g^b, g^c)$ for  a generator $g$ and uniformly random $a, b, c$.

\begin{definition}[Decisional Diffie-Hellman (DDH)]
    Given a cyclic group $G$ and an element $g$ of order $q$, consider the following game between adversary $\mathcal{A}$ and challenger $\mathcal{C}$:
    \begin{enumerate}
        \item $\mathcal{C}$ chooses $a, b, c$ uniformly at random from $\mathbb{Z}_q$, and calculates $x_0=g^c$ and $x_1=g^{ab}$.
        \item $\mathcal{C}$ sends $g^a$ and $g^b$ to $\mathcal{A}$.
        \item $\mathcal{C}$ chooses a random bit $i$ and sends $x_b$ to $\mathcal{A}$.
        \item $\mathcal{A}$ outputs a bit $b'$.
    \end{enumerate}
    $\mathcal{A}$ wins if $b' = i$. If for all PPT adversaries $\mathcal{A}$, there exists a negligible function $\negl$ such that $\Pr[\mathcal{A}\text{ wins}]<\frac{1}{2}+\negl(q)$, we say \textit{the DDH assumption holds in} $G$.
\end{definition}
We will now prove IND-CPA security of ElGamal by reduction to DDH.
\begin{theorem}
    If the DDH assumption holds in $\mathbb{G}$, the ElGamal cryptosystem (with security parameter $q$) is IND-CPA secure.
\end{theorem}
\begin{proof}
    Let $\mathcal{A}$ be a PPT adversary for IND-CPA. Suppose that $\mathcal{A}$ can win the IND-CPA game with probability $\frac{1}{2}+\varepsilon(q)$. Consider a DDH adversary $B$. On input $g^a, g^b, x$, it acts as the challenger to $\mathcal{A}$, giving it the alternative encryption oracle $\Enc_B(m)=(g^b, x\cdot m)$.
    
    \textbf{Case 1}: if $x=g^c$, then $\Enc_B(m)$ is a uniformly random pair of elements, so $\Pr[\mathcal{A}\text{ wins}]=\frac{1}{2}$.
    
    \textbf{Case 2}: if $x=g^{ab}$, then $\Enc_B(m)$ is a faithful encryption of $m$ with randomness $g^b$ and secret key $a$, so $\mathcal{A}$ wins with probability $\frac{1}{2}+\varepsilon(q)$.

    By outputting the same bit as $\mathcal{A}$, $\mathcal{B}$ wins with probability at most $\frac{1}{2}+\varepsilon(q)$; but since the DDH assumption holds in $\mathbb{G}$, $\varepsilon(q)\leq\negl(q)$, so the ElGamal cryptosystem is IND-CPA secure.
\end{proof}

\subsection{Re-randomisation of ciphertexts}
A useful property of ElGamal is that an encryption of $m$ $(c_1, c_2)=(g^r, mh^r)$ can easily be \textit{re-randomised} to produce a different encryption of $m$: choose $\rho\in\mathbb{Z}_q$, and output $(c_1^\rho, c_2^\rho)$. Given the output, it is computationally infeasible to identify that it is a re-randomisation of the input ciphertext.

If we know the randomness $r$, we can also give a proof that a ciphertext is a re-randomisation: in the notation above, we reveal $r(\rho-1)\bmod q$. Then an observer can calculate $(c_1g^{r(\rho-1)}, c_2g^{r(\rho-1)})=(g^{r+r(\rho-1)}, mh^{r(\rho-1)})=(g^{r\rho}, mh^{r\rho})=(c_1^\rho, c_2^\rho)$, but does not learn the randomness $\rho$.
% TODO: Expand on this. Proofs of re-randomisation, etc.
\subsection{The homomorphic property of ElGamal}
Interestingly, the encryption and decryption functions in ElGamal are group homomorphisms. This allows us to verifiably compute certain functions of ciphertexts without ever revealing their decryptions.
\begin{lemma}\label{lem-mul-homom}
    $\Enc_r$ and $\Dec$ are multiplicative group homomorphisms.
\end{lemma}
\begin{proof}
    We will treat $\Enc_r$ as a function $\mathbb{Z}_q\times\mathbb{G}_q\rightarrow\mathbb{G}_q\times\mathbb{G}_q$ to account for the parameter $r$.\footnote{We will use addition as the group operation on $\mathbb{Z_q}$.}

    Let $x,y\in\mathbb{G}_p$ and $r_1,r_2\in\mathbb{Z}$. For encryption:
    
    $$\Enc_{r_1}(x)\cdot\Enc_{r_2}(y)=(g^{r_1},xh^{r_1})\cdot(g^{r_2},yh^{r_2})=(g^{r_1+r_2},xyh^{r_1+r_2})=\Enc_{r_1+r_2}(xy)$$

    For decryption:

    $$\Dec(g^{r_1},xh^{r_1})\cdot\Dec(g^{r_2},yh^{r_2})=xg^{r_1s}g^{-r_1s}yg^{r_2s}g^{-r_2s}=xy=\Dec(g^{r_1+r_2},xyh^{r_1+r_2})$$
\end{proof}

We now construct an \textit{additive} homomorphism:
\begin{lemma}
    $e:\mathbb{Z}_q\times\mathbb{Z}_q\rightarrow\mathbb{G}_q\times\mathbb{G}_q,\ e(r, x)=\Enc_r(g^x)$ is an additive group homomorphism.
\end{lemma}
\begin{proof}
    We perform a straightforward calculation:
    $$e(r_1, x)\cdot e(r_2,y)=(g^{r_1},g^xh^{r_1})\cdot(g^{r_2},g^yh^{r_2})=(g^{r_1+r_2},g^{x+y}h^{r_1+r_2})=e(r_1+r_2, x+y)$$
\end{proof}
Unfortunately, decryption now reduces to the discrete logarithm problem -- exactly what we assume is hard to give ElGamal its security properties. In practice, this limits the additive homomorphic property to messages drawn from a small set\footnote{A not-very-clever implementation we tested on an Intel Core i7 - 8550U CPU was able to compute discrete logarithms for 10-bit messages with a 3072-bit key in less than 20 milliseconds.} (so that the discrete logarithm can be computed quickly enough).

This yields a variant of ElGamal referred to as \textit{exponential ElGamal}.
\subsection{Sharing a key between trustees}
It is easy to generalise ElGamal to a distributed system of $n$ trustees. We modify the definition as follows:
\begin{definition}[The distributed ElGamal encryption scheme]
    Let $\mathbb{G}$ be a cyclic group and $g\in\mathbb{G}$ be an element of prime order $q$. For $0\leq i<n$, the $i$th trustee chooses $s_i\in\mathbb{Z}_q$ uniformly at random, and publishes $h_i=g^{s_i}$. Let $H=\prod_i h_i=g^{\sum_i s_i}$. The public key of the scheme is $(\mathbb{G}, g, q, H)$, and the secret keys are $(\mathbb{G}, g, q, s_i)$. We will choose messages in the group $\mathbb{Z}^\times_q$.

    Given a uniformly random $r\in\mathbb{Z}$, define the encryption $\Enc_r:\mathbb{G}\rightarrow\mathbb{G}\times\mathbb{G}$ of a message $m$ to be
    
    $$\Enc_r(m) = (g^r, m\cdot H^r)$$

    Define the decryption $\DecDist:\mathbb{G}\times\mathbb{G}\rightarrow \mathbb{G}$ of a ciphertext $(c_1, c_2)$ to be
    
    $$\DecDist(c_1,c_2)=c_2\cdot c_1^{-\sum_i s_i}$$
    
    To calculate this value, the $i$th trustee should calculate $c_1^{s_i}$ and publish a commitment $\commit\left(c_1^{s_i};r_i\right)$ for random $r_i$. Once all trustees have published their commitments, the $i$th trustee publishes their opening $\left(c_1^{s_i}, r_i\right)$. They can then recover the decryption factor
    
    $$c_1^{\sum_i s_i}=\prod_i{c_1^{s_i}}$$
\end{definition}
In this manner, decryption can only be performed if all trustees agree to take part.
\subsection{Pedersen commitments}
\newpage
\section{Zero-knowledge proofs and cryptographic mixes}\label{app-proof}
\subsection{Proof of knowledge for discrete logarithms}
Consider two parties: $\mathcal{P}$, the prover, and $\mathcal{V}$, the verifier. $\mathcal{P}$ publishes an ElGamal public key $(g,p,q,h)$. $\mathcal{P}$ claims that a ciphertext $(c_1, c_2)$ decrypts to a message $m$. $\mathcal{V}$ would like $\mathcal{P}$ to prove this claim, but $\mathcal{P}$ cannot reveal the secret key $(g,p,q,s)$ to allow $\mathcal{V}$ to check this herself.

We first discuss how $\mathcal{P}$ can prove that he knows a secret $r$ such that $g^r=h$, and expand on various applications of this protocol later, following the treatment of \cite{damgaard2002sigma}. Suppose $\mathcal{P}$ has published an element $g\in\mathbb{Z}^\times_p$ of order $q$ and $h\in\mathbb{Z}^\times_q$. $\mathcal{V}$ would like to check that $\mathcal{P}$ knows $r$ such that $h=g^r$. Consider the below protocol, due to Schnorr:
\begin{enumerate}
    \item $\mathcal{P}$ chooses $w\in\mathbb{Z}^\times_q$ uniformly at random, and sends $a=g^w\bmod p$ to $\mathcal{V}$.
    \item $\mathcal{V}$ chooses a challenge $e\in\mathbb{Z}_{2^t}$ uniformly at random, and sends it to $\mathcal{P}$ (where $2^t<q$).
    \item $\mathcal{P}$ sends $z=w+er\bmod q$ to $\mathcal{V}$. She checks that $g^z=ah^e\bmod p$.
\end{enumerate}
\subsubsection{Completeness}
\subsubsection{Soundness}
\subsubsection{Zero-knowledge}
\subsection{Application: proof of plaintext knowledge}
A direct application of Schnorr's protocol is proving plaintext knowledge for an ElGamal ciphertext. $\mathcal{P}$ generates an ElGamal ciphertext $(c_1, c_2)=(g^r, mh^r)$ and uses the protocol to prove that he knows

$$\dlog_g{c_1}=r$$

While this is not a direct proof that he knows $m$, someone who knows $r$ can calculate $h^r$, and therefore calculate $m$. Thus, $\mathcal{P}$ has demonstrated that he knows the plaintext message for a given ciphertext.

\subsection{Proof of equality of discrete logarithms}
Consider a similar protocol to Schnorr's, modified to produce a proof of \textit{equality} for discrete logarithms:
\begin{enumerate}
    \item $\mathcal{P}$ chooses $w\in\mathbb{Z}^\times_q$ uniformly at random, and sends $a=g^w\bmod p,b=g^{rw}\bmod p$ to $\mathcal{V}$.
    \item $\mathcal{V}$ chooses a challenge $e\in\mathbb{Z}_{2^t}$ uniformly at random, and sends it to $\mathcal{P}$ (where $2^t<q$).
    \item $\mathcal{P}$ sends $z=w+es\bmod q$ to $\mathcal{V}$. She checks that $g^z=ah^e\bmod p$ and $(g^r)^z=b(h^r)^e\bmod p$.
\end{enumerate}

\subsubsection{Application: proof of decryption}
What does it mean to \textit{prove} that $\Dec(g^r,mh^r)=m$? We would like to show that $m\cdot h^r\cdot g^{-rs}=m$ for all $r$ and some $s$, both of which are unknown to the verifier. We should have both $h=g^s$ and $h^r=(g^r)^s$; in other words, we would like to show that

$$\dlog_g{h}=\dlog_{g^r}{h^r}$$

We can then use the previous proof to achieve this.
\subsection{The Fiat-Shamir heuristic}
\subsection{A simple cryptographic mix}
%TC:endignore 
\end{document}
